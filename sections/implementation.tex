This chapter details the underlying implementation of the modules of Rymd and Shuttle (Data Storage, Communication, Authentication, Encryption), as well as documenting and motivating the different choices of required technologies. The latter is a crucial part in the development of web application systems: composing appropriate technologies and tools for the goal based on given criterias.

\section{Authentication}
Since the default authentication implementation utilizes Namecoin, which can not be accessed directly from a web application, a gateway service needs to be used. Therefore, the domain of authentication spans over several parts in separate systems:
\begin{description}
  \item[DHT] A Node.js\footnote{http://nodejs.org} based server that looks up entries in the Namecoin blockchain. It is also used to keep track of session-based IDs, as described under~\ref{sec:communication}. This is the only module that runs outside of the Rymd library.
  \item[DHT-Client] Client-side interface module to the DHT.
  \item[ConnectionHandler] Submodule in the Rymd library. Implements the Needham-Schroeder-Lowe authentication business logic.
\end{description}

The idea with this separation is that the authentication algorithm is part of the core library, while derivative projects should be able to replace $DHT$ and $DHT-client$ with implementations using other stores like Ethereum or Keybase without having to consider writing a secure authentication protocol, should they so desire.

\section{Cryptography}
\label{sec:cryptography}
%TODO: Rewrite, explain "secure primitives". Probably this whole sentence should be removed./Robert
%In Rymd, security is achieved through secure primitives, user restrictions and by the use of cryptographic communication libraries.
% uses the Web Crypto Api for encryption (3AES - 1024) ,decryption key import and export ,
At this stage Rymd only runs in the very recent development versions of Google Chrome or Chromium.
Even if the implementations provided by these browsers supply key generation, there is no support for persisting keys between sessions or even exporting private keys. Until this is implemented, the Rymd crypto module therefore generates keys on its own; doing this is bad practice and is only performed in order to get a prototype running.

\subsection{Dependecies}
The Crypto module is based around the use of cryptographic communication libraries; the module is strutured in a way such that cryptoback.js handles key generation and parsing while the rest is handled by the crypto.js module.
\begin{Code}
\begin{lstlisting}[caption={Included database operations}, label={lst:api}]
 //dependecies cryptoback.js
  var rsa = require('bignumber-jt'),
      Q = require('q');

 //dependecies crypto.js
  var root = this,
    Q = require('q'),
    cryptojs = require('crypto-js'),
    utils = require("./cryptoback");
\end{lstlisting}
\end{Code}
As previously mentioned, the Web Crypto API lacks functionality for storing keys between sessions or even exporting private keys. In order to support key storage between sessions, the key generation is moved out of the API and handled by a library \emph{bignumber-jt} \cite{Bignumber:Online}; The key is then parsed to a certificate.
All certificate have a static key size where asymmetric keys are of $1024bits$ and symmetric ($AES-CBC$) are of $256bits$; none are explicitly generated via the API.

%\subsection{Interface}
% before it's imported into its low-level interface. %TODO: Proper reference
%\begin{Code}
%\begin{lstlisting}[caption={Common database operations}, label={lst:api}]
% generateKeyPair: function() -> Promise({Uint8array,Uint8array})
% exportKey: function(WebCrypto::Key) -> Promise({Uint8array})
% importKey: function(String,Uint8array) -> Promise(WebCrypto::Key)
% signKey: function(WebCrypto::Key,Uint8Array) -> Promise
% verifyKey: function(WebCrypto::Key,Uint8Array,Uint8Array) -> Promise
% encrypt**: function(WebCrypto::Key,Uint8Array??) -> Promise(Arraybuffer)
% decrypt**: function(WebCrypto::Key,Uint8Array??) -> Promise(Arraybuffer)
% hash**: function(blob)  -> Promise(blob)
% generateSymmetricKey: function() -> Promise(WebCrypto::Key)
% \end{lstlisting}
%\end{Code}

\subsection{Algorithms}
The Encryption uses two algorithms, namely the $RSAES-PKCS1-v1.5$ and the $AES-CBC$.
AES-CBC is a symmetric key AES based using cipher block chaining; it is the only symmetric algorithm implemented at the time of writing, besides it is fast\cite{AESISFAST:Online} and simple to use.
$RSAES-PKCS1-v1.5$ - an AES implementation based on the RSA algorithm.
\begin{Code}
\begin{lstlisting}[caption={Algorithms implemented}, label={lst:api}]
  var generationAlgorithmSign =  {
    name: "RSASSA-PKCS1-v1_5",
    modulusLength: 2048,
    publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
    hash: {
      name: "SHA-256"
    }
  },

  generationAlgorithmEncrypt =  {
    name: "RSAES-PKCS1-v1_5",
    modulusLength: 2048,
    publicExponent: new Uint8Array([0x01, 0x00, 0x01])
  },

  aesAlgorithmKeyGen = {
    name: "AES-CBC",
    length: 256
  },

 specFormats ={
    public: 'spki',
    private: 'pkcs8',
    secret: 'raw'
  }
\end{lstlisting}
\end{Code}
Regarding $RSAES-PKCS1-v1.5$,the fact that it uses RSA is inline with our guidelines since it allows the key to be reused for both signing and encryption (se table \ref{table:webcryptoapi})..
Considering DSA algorithms: the DSA is faster for signing and key generating but slower when it comes to signature checking and it also lack the ability to preform encryption with
Regarding accessibility, both algorithms are included in the Web Crypto API and are therefore provided by the browser as black boxes.
% add text about hashing
% why is the hashing in
\begin{table}[h]
\centering
\begin{tabular}{lcccccc}
Algorithm name & Type & Encrypt & Decrypt & Sign & Verify & ImportKey \\
RSAES-PKCS1-v1\_5 & ASYM & x & x &  &  & x \\
RSASSA-PKCS1-v1\_5 & ASYM &  &  & x & x & x \\
RSA-PSS & ASYM &  &  & x & x & x \\
RSA-OAEP & ASYM & x & x &  &  & x \\
ECDSA & ASYM &  &  & x & x & x \\
AES-CTR & SYM & x & x &  &  & x \\
AES-CBC & SYM & x & x &  &  & x \\
AES-CMAC & SYM &  &  & x & x & x \\
AES-GCM & SYM & x & x &  &  & x \\
AES-CFB & SYM & x & x &  &  & x
\end{tabular}
\caption{W3C Draft Table}
\label{table:webcrypoapi}
\end{table}
In commercial terms as for our project, RSA is clearly the winner; commercial RSA certificates are much more widely deployed than DSA certificates.
Furthermore, the asymmetric keys are wrapped in PKCS\#8 and SPKI certificates while the symmetric key exist in raw format.
The Private-Key Information Syntax Standard (PKCS\#8) -  defines a way to store the private key and the Simple public key infrastructure (SPKI) - defines a way to store the public key.
All three standards was chosen because they are the only three formats that is currently supported by Chromium \cite{ImplementedChromium:Online}.
W3C - the organization behind the Web Crypto API, have announced their intention to implement the Web Crypto Key Discovery API \cite{WebCryptoKeyDiscovery:Online} a secure key store which would allow Rymd to persist keys between sessions in a secure manner.
Web Crypto Key Discovery API was originally thought as a part of the Web Crypto API was extracted in favor overall of decreased implementation complexity.

% TODO Johannes

\section{Data storage}
\label{sec:datastorage}

% TODO Johan: Oversee this.

The main task for the data storage module was to abstract away the low-level methods in IndexedDB (the backing store used, see section~\ref{sec:indexeddb}). By the use of the concept of \emph{promises}\footnote{http://en.wikipedia.org/wiki/Promise\_(programming)}, the asynchronous, callback-based methods in the IndexedDB API could be made very streamlined and simple to manage. An example can be found in listing~\ref{lst:api}

\begin{Code}
\begin{lstlisting}[caption={Common database operations}, label={lst:api}]
var Store = new IndexedDbStore("myStore")

// Fetch all records as an array
Store.all().then(function(records) { ... })

// Create a record
Store.create("A record").then(function(record){ ... })

// Insert a record
Store.save("A record").then(function(guid){ ... })

// Fetch a record by GUID
Store.get(guid).then(function(record) { ... })

// Delete a record by GUID
Store.destroy(guid).then(function(record) { ... })
\end{lstlisting}
\end{Code}

The largest challenge came to the edge cases when storing files, or as they are called in web browser: \emph{Blobs}. Since at present only Firefox can store blobs directly in IndexedDB, an alternate route had to be taken for other browsers. Initially the module used conditionals and converted incoming data to and from \emph{ArrayBuffers} (the browser construct for raw byte streams). But since ArrayBuffers are just the raw data, all metadata for the blobs (such as filename, timestamps, size) would be lost when saving as an ArrayBuffer. In early versions of the data storage module this metadata would be stored in a separate store in the database, but this was too tightly coupled and was removed. The final implementation is storing data as-is â€“ any metadata must be saved explicitly in a separate operation.

The data storage module is a separate repository and the source is available at https://github.com/rymdjs/data-storage.

\section{Communication}
\label{sec:p2p}
% TODO: Niklas

% - built on top of peerjs, TODO (not sure how to reference to github)
Rymd leverages the open source project PeerJS\footnote{http://peerjs.com}, which simplifies sending peer-to-peer data between clients. PeerJS utilizes WebRTC and is essentially split into two components: a server which acts as the signaling channel, and a client side API which interacts with the server as well as other peers. The server only handles the brokering of connections, which implies that only the data necessary for negotiating a connection is sent through this point. For communication between the server and the clients, PeerJS utilizes both WebSockets and XMLHttpRequest \cite{PeerjsGithub:2014:Online}. After a connection has been setup between two clients, the server is no longer needed in order for them to communicate.

% - explain how peer.js works.
The following steps explain how PeerJS brokers connections:
\begin{enumerate}
\item Two clients connect to the PeerJS server, using the client side API.
\item The server returns unique IDs for each of the clients.
\item One of the clients connects to the other using the client side API, where the unique ID for the other one is provided. The PeerJS server then forwards the information needed to set up a peer-to-peer connection to the other client.
\end{enumerate}
% modularity and such
In line with the project guidelines regarding modularity, PeerJS-specific code is separated into a module of its own. If the requirements are to change, then those changes are contained in a single module.



\section{Testing}
\label{sec:testing}
Automatic unit tests have been implemented where possible. No integration or functional tests have been written for testing larger parts of the system. This is due to the fast iteration of the library's interface and constant change in implementation.
% TODO Johan: more here?
